<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Case Studies(Rahul)</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f2eb;
            color: #5a3e36;
        }

        header {
            background-color: #8b5e3c;
            color: #fff;
            padding: 2em 0;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5em;
        }

        header p {
            margin: 0.5em 0 0;
            font-size: 1.2em;
        }

        section {
            padding: 2em;
            margin: 1em auto;
            max-width: 900px;
            background-color: #fff7ef;
            border: 1px solid #d7b8a5;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #8b5e3c;
            border-bottom: 2px solid #d7b8a5;
            padding-bottom: 0.5em;
        }

        dl {
            margin: 0;
        }

        dt {
            font-weight: 600;
            color: #7a5230;
            margin-top: 1em;
        }

        dd {
            margin-left: 1.5em;
            margin-bottom: 0.5em;
        }

        footer {
            text-align: center;
            padding: 1em 0;
            background-color: #8b5e3c;
            color: #fff;
            border-top: 2px solid #d7b8a5;
        }

        footer p {
            margin: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #8b5e3c;
            color: white;
        }

        .graph-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
        }

        svg {
            border: 1px solid #ddd;
            border-radius: 12px;
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <header>
        <h1>Rahul's Business Case Studies</h1>
        <p>Exploring Sustainable and Smart Solutions for Shyamora</p>
    </header>

    <section>
        <h2>1. Sustainable Waste Management System</h2>
        <dl>
            <dt>SDG Goal</dt>
            <dd>11</dd>
            <dt>Target</dt>
            <dd>11.6</dd>
            <dt>Indicator</dt>
            <dd>11.6.1</dd>
            <dt>Problem</dt>
            <dd>Efficiently route waste collection vehicles to minimize time and fuel usage while covering all city areas.</dd>
            <dt>Algorithm</dt>
            <dd>Dijkstra's Algorithm , Bellman Ford</dd>
            <dt>Why Dijkstra</dt>
            <dd>Dijkstra's Algorithm helps find the shortest path from a source node to all other nodes in a weighted graph, making it ideal for routing problems.</dd>
            <dt>Implementation Details</dt>
            <dd>The graph was implemented using an adjacency list to represent the city roads.</dd>
            <dd>The Heap Data Structure (Min-Heap) was used to efficiently extract the next closest node during the execution of Dijkstra’s algorithm.</dd>
            <dd>Greedy Technique: Ensured the shortest path was chosen at each step.</dd>
            <dt>Efficiency Analysis</dt>
            <dd>The time complexity of Dijkstra's algorithm is O(ElogV), where E is the number of edges and V is the number of vertices (nodes). This makes it very efficient for large graphs, especially when implemented with a priority queue (Min-Heap). The algorithm works well for sparse and dense graphs, though it may not perform optimally for graphs with negative edge weights.</dd>
            <a href="dijkstra.html" target="_blank">Dijkstra's code</a>
            <dt>Why Bellman Ford</dt>
            <dd>Bellman-Ford handles graphs with negative weights, which might arise if we associate penalties or costs with certain routes (e.g., congested or restricted zones).</dd>
            <dd>Use Case in Waste Management: If certain roads are less preferred due to environmental concerns or vehicle restrictions, you can assign them negative weights.</dd>
            <dd>Drawback: It is slower than Dijkstra’s, with a time complexity of O(VE), but is more flexible.</dd>
            <dt>Efficiency Analysis</dt>
            <dd>Bellman-Ford has a time complexity of O(VE), where V is the number of vertices and E is the number of edges. This is less efficient than Dijkstra’s for graphs with many edges, but it is the preferred algorithm when dealing with graphs that have negative edge weights or when flexibility is required.</dd>
            <a href="bellman_ford.html" target="_blank">Bellman Ford code</a>
        </dl>
        <h2>Basic Data</h2>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Data</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Number of Roads</td>
                    <td>250</td>
                </tr>
                <tr>
                    <td>Number of Waste Collection Vehicles</td>
                    <td>20</td>
                </tr>
                <tr>
                    <td>Number of Nodes (City Junctions)</td>
                    <td>150</td>
                </tr>
                <tr>
                    <td>Average Distance Covered per Route (km)</td>
                    <td>30</td>
                </tr>
            </tbody>
        </table>
 <dt>Sorting Algorithm</dt>
            <dd>Heap Sort</dd>
            <dt>Why Heap Sort</dt>
            <dd>Heap Sort is used to efficiently sort the data (e.g., vehicle routes or priorities) based on a criterion (e.g., minimal time or cost). It is particularly useful when the list of routes or priorities needs to be dynamically adjusted.</dd>
            <dt>Heap Sort Code (C++)</dt>
            <dd>
                <pre>
#include <iostream>
#include <vector>
using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2*i + 1;
    int right = 2*i + 2;
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    heapSort(arr);
    for (int num : arr) cout << num << " ";
    return 0;
}
                </pre>
            </dd>
        
    </section>

    <section>
        <h2>2. Renewable Energy Infrastructure</h2>
        <dl>
            <dt>SDG Goal</dt>
            <dd>11</dd>
            <dt>Target</dt>
            <dd>11.3</dd>
            <dt>Indicator</dt>
            <dd>11.3.2</dd>
            <dt>Problem</dt>
            <dd>Optimize placement of solar panels or hydroelectric plants to maximize energy generation and minimize cost.</dd>
            <dt>Algorithm</dt>
            <dd>Greedy Algorithm or Linear Programming</dd>
            <dt>Why</dt>
            <dd>Greedy Algorithms are effective for resource allocation problems, while Linear Programming ensures optimal solutions under multiple constraints.</dd>
            <dt>Implementation Details</dt>
            <dd>Modeling Energy Needs: Energy demand and supply data were collected for various city zones.</dd>
            <dd>Greedy Technique: Used to maximize energy generated per unit cost.</dd>
            <dd>Linear Programming: Applied to balance multiple constraints like land availability and energy demand.</dd>
            <dt>Efficiency Analysis</dt>
            <dd>Greedy algorithms typically have a time complexity of O(n log n) or O(n), depending on the specific implementation (e.g., sorting). Linear programming can be solved using methods like the Simplex algorithm, which has a worst-case time complexity of O(2^n), though practical performance is often much better due to the problem's constraints and structure.</dd>
            <dd>The combination of these methods is well-suited for optimization problems with multiple constraints and large datasets.</dd>
            <a href="greedy.html" target="_blank">Greedy (Linear programming) code</a>
        </dl>
        <h2>Basic Data</h2>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Data</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Number of Solar Panels</td>
                    <td>50</td>
                </tr>
                <tr>
                    <td>Number of Hydroelectric Plants</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>Average Energy Generation per Day (kWh)</td>
                    <td>1000</td>
                </tr>
                <tr>
                    <td>Energy Demand Covered (%)</td>
                    <td>60</td>
                </tr>
            </tbody>
        </table>
 <dt>Sorting Algorithm</dt>
            <dd>Merge Sort</dd>
            <dt>Why Merge Sort</dt>
            <dd>Merge Sort is used when we need to divide the problem (e.g., sorting energy requirements or locations) into smaller pieces, sort them, and then merge the results. It's ideal for handling large datasets that need to be processed in a divide-and-conquer manner.</dd>
            <dt>Merge Sort Code (C++)</dt>
            <dd>
                <pre>
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        merge(arr, left, mid);
        merge(arr, mid + 1, right);
        int n1 = mid - left + 1;
        int n2 = right - mid;
        vector<int> L(n1), R(n2);
        for (int i = 0; i < n1; i++) L[i] = arr[left + i];
        for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) arr[k++] = L[i++];
            else arr[k++] = R[j++];
        }
        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    merge(arr, 0, arr.size() - 1);
    for (int num : arr) cout << num << " ";
    return 0;
}
                </pre>
            </dd>
        
    </section>

    <section>
        <h2>3. Smart Transportation System</h2>
        <dl>
            <dt>SDG Goal</dt>
            <dd>11</dd>
            <dt>Target</dt>
            <dd>11.2</dd>
            <dt>Indicator</dt>
            <dd>11.2.1</dd>
            <dt>Problem</dt>
            <dd>Manage traffic efficiently and design routes for electric buses to minimize emissions and travel time.</dd>
            <dt>Algorithm</dt>
            <dd>Prim's Algorithm</dd>
            <dt>Why</dt>
            <dd>Prim's Algorithm is ideal for designing minimal spanning trees for infrastructure planning.</dd>
            <dt>Implementation Details</dt>
            <dd>Traffic Network as Graph: Nodes represented junctions, and edges represented roads with weights (travel time).</dd>
            <dd>Prim’s Algorithm: Applied to plan the minimum spanning tree for electric bus charging stations.</dd>
            <dt>Efficiency Analysis</dt>
            <dd>Prim's Algorithm has a time complexity of O(E log V), where E is the number of edges and V is the number of nodes. It is highly efficient when the graph is dense and is typically used when all nodes need to be connected with minimal edge weights.</dd>
            <a href="prims.html" target="_blank">Prim's code</a>
              <dt>Another Algorithm</dt>
            <dd>Kruskal's Algorithm</dd>
            <dt>Why</dt>
            <dd>Kruskal’s Algorithm is particularly efficient for graphs with fewer edges (sparse graphs) due to its approach to constructing the Minimum Spanning Tree (MST)</dd>
            <dt>Efficiency Analysis</dt>
            <dd>Kruskal's Algorithm has a time complexity of O(E log E), where E is the number of edges. It is efficient for sparse graphs where the number of edges is much smaller than the square of the number of nodes. Sorting edges and applying union-find operations make it faster for such graphs.</dd>
            <a href="kruskals.html" target="_blank">Kruskal's code</a>
        </dl>
        <h2>Basic Data</h2>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Data</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Number of Bus Routes</td>
                    <td>25</td>
                </tr>
                <tr>
                    <td>Number of Electric Buses</td>
                    <td>50</td>
                </tr>
                <tr>
                    <td>Average Commute Time per Route (minutes)</td>
                    <td>45</td>
                </tr>
                <tr>
                    <td>Reduction in Traffic Congestion (%)</td>
                    <td>30</td>
                </tr>
            </tbody>
        </table>
<dt>Sorting Algorithm</dt>
            <dd>Quick Sort</dd>
            <dt>Why Quick Sort</dt>
            <dd>Quick Sort is effective for sorting large amounts of data (e.g., bus routes or traffic data) quickly. It has an average time complexity of O(n log n) and is suitable for real-time systems like smart transportation.</dd>
            <dt>Quick Sort Code (C++)</dt>
            <dd>
                <pre>
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    quickSort(arr, 0, arr.size() - 1);
    for (int num : arr) cout << num << " ";
    return 0;
}
                </pre>
            </dd>
        
    </section>

    <footer>
        <p>&copy; 2024 Rahul's Case Studies. All Rights Reserved.</p>
    </footer>
</body>
</html>
